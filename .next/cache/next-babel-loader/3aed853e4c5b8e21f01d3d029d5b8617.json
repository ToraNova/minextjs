{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\n\n/*\n * This is a helper utility that allows\n * authentication for pages\n * This is reusable across pages\n * The JWT token is stored as cookies\n */\n//redundant but this allows me to explicitly know fetch is from this package\nimport fetch from 'isomorphic-unfetch'; //This class can be used as a service handler for login pages\n//or any form of authentication\n\nexport default class AuthService {\n  //if domain is passed, then use that else fallback to localhost:5000\n  constructor(domain) {\n    this.domain = domain || 'http://localhost:1996';\n    this.fetch = this.fetch.bind(this);\n    this.login = this.login.bind(this);\n    this.getProfile = this.getProfile.bind(this);\n  } //signup a user\n\n\n  signUp(email, name, password) {\n    return this.fetch(`${this.domain}/user/add`, {\n      method: 'POST',\n      body: _JSON$stringify({\n        email,\n        name,\n        password\n      })\n    }).then(res => {\n      this.setToken(res.token); //arms the token\n\n      return this.fetch(`${this.domain}/user/profile`, {\n        method: 'GET'\n      });\n    }).then(res => {\n      this.setProfile(res);\n      return _Promise.resolve(res);\n    });\n  } // Get a token\n\n\n  login(email, password) {\n    return this.fetch(`${this.domain}/user/login`, {\n      method: 'POST',\n      body: _JSON$stringify({\n        email,\n        password\n      })\n    }).then(res => {\n      this.setToken(res.token); //arms the token\n\n      return this.fetch(`${this.domain}/user/profile`, {\n        method: 'GET'\n      });\n    }).then(res => {\n      this.setProfile(res);\n      return _Promise.resolve(res);\n    });\n  } // Checks if there is a saved token and it's still valid\n\n\n  loggedIn() {\n    //TODO : check validity of token ?\n    const token = this.getToken(); //return !!token && !isTokenExpired(token) // handwaiving here\n\n    return !!token;\n  }\n\n  setProfile(profile) {\n    // Saves profile data to localStorage\n    localStorage.setItem('profile', _JSON$stringify(profile));\n  }\n\n  getProfile() {\n    // Retrieves the profile data from localStorage\n    const profile = localStorage.getItem('profile');\n    return profile ? JSON.parse(localStorage.profile) : {};\n  } // Saves user token to localStorage\n\n\n  setToken(idToken) {\n    localStorage.setItem('token', idToken);\n  } // Retrieves the user token from localStorage\n\n\n  getToken() {\n    return localStorage.getItem('token');\n  } // Clear user token and profile data from localStorage\n  // and logout user (from all device /all)\n\n\n  logout() {\n    //only proceed if the user IS logged in\n    return this.fetch(`${this.domain}/user/logout/all`, {\n      method: 'POST'\n    }).then(res => {\n      //response is 204\n      console.log(\"Removing Storage\");\n      localStorage.removeItem('token');\n      localStorage.removeItem('profile');\n      return _Promise.resolve(res);\n    });\n  } // raises an error in case response status is not a success\n\n\n  _checkStatus(response) {\n    if (response.status >= 200 && response.status < 300) {\n      return response;\n    } else {\n      var error = new Error(response.statusText);\n      error.response = response;\n      throw error;\n    }\n  } // performs api calls sending the required authentication headers\n  // this is actually a wrapper around the 'fetch' function from\n  // isomorphic fetch\n\n\n  fetch(url, options) {\n    const headers = {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    };\n\n    if (this.loggedIn()) {\n      headers['Authorization'] = 'Bearer ' + this.getToken();\n    }\n\n    return fetch(url, _objectSpread({\n      headers\n    }, options)).then(this._checkStatus).then(response => response.json());\n  }\n\n}","map":{"version":3,"sources":["/home/cjason/prodev/minextjs/utils/authser.js"],"names":["fetch","AuthService","constructor","domain","bind","login","getProfile","signUp","email","name","password","method","body","then","res","setToken","token","setProfile","resolve","loggedIn","getToken","profile","localStorage","setItem","getItem","JSON","parse","idToken","logout","console","log","removeItem","_checkStatus","response","status","error","Error","statusText","url","options","headers","json"],"mappings":"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","sourcesContent":["/*\n * This is a helper utility that allows\n * authentication for pages\n * This is reusable across pages\n * The JWT token is stored as cookies\n */\n\n//redundant but this allows me to explicitly know fetch is from this package\nimport fetch from 'isomorphic-unfetch'\n\n//This class can be used as a service handler for login pages\n//or any form of authentication\nexport default class AuthService {\n\t//if domain is passed, then use that else fallback to localhost:5000\n\tconstructor(domain) {\n\t\tthis.domain = domain || 'http://localhost:1996'\n\t\tthis.fetch = this.fetch.bind(this)\n\t\tthis.login = this.login.bind(this)\n\t\tthis.getProfile = this.getProfile.bind(this)\n\t}\n\n\t//signup a user\n\tsignUp(email, name, password){\n\t\treturn this.fetch(`${this.domain}/user/add`, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({\n\t\t\temail,\n\t\t\tname,\n\t\t\tpassword\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setToken(res.token) //arms the token\n\t\t\treturn this.fetch(`${this.domain}/user/profile`, {\n\t\t\tmethod: 'GET'\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setProfile(res)\n\t\t\treturn Promise.resolve(res)\n\t\t})\n\t}\n\n\t// Get a token\n\tlogin(email, password) {\n\t\treturn this.fetch(`${this.domain}/user/login`, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({\n\t\t\temail,\n\t\t\tpassword\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setToken(res.token) //arms the token\n\t\t\treturn this.fetch(`${this.domain}/user/profile`, {\n\t\t\tmethod: 'GET'\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setProfile(res)\n\t\t\treturn Promise.resolve(res)\n\t\t})\n\t}\n\n\t// Checks if there is a saved token and it's still valid\n\tloggedIn(){\n\t\t//TODO : check validity of token ?\n\t\tconst token = this.getToken()\n\t\t//return !!token && !isTokenExpired(token) // handwaiving here\n\t\treturn !!token\n\t}\n\n\tsetProfile(profile){\n\t\t// Saves profile data to localStorage\n\t\tlocalStorage.setItem('profile', JSON.stringify(profile))\n\t}\n\n\tgetProfile(){\n\t\t// Retrieves the profile data from localStorage\n\t\tconst profile = localStorage.getItem('profile')\n\t\treturn profile ? JSON.parse(localStorage.profile) : {}\n\t}\n\n\t// Saves user token to localStorage\n\tsetToken(idToken){\n\t\tlocalStorage.setItem('token', idToken)\n\t}\n\n\t// Retrieves the user token from localStorage\n\tgetToken(){\n\t\treturn localStorage.getItem('token')\n\t}\n\n\t// Clear user token and profile data from localStorage\n\t// and logout user (from all device /all)\n\tlogout(){\n\t\t//only proceed if the user IS logged in\n\t\treturn this.fetch(`${this.domain}/user/logout/all`, {\n\t\t\tmethod: 'POST'\n\t\t}).then(res => {\n\t\t\t//response is 204\n\t\t\tconsole.log(\"Removing Storage\")\n\t\t\tlocalStorage.removeItem('token');\n\t\t\tlocalStorage.removeItem('profile');\n\t\t\treturn Promise.resolve(res)\n\t\t})\n\t}\n\n\t// raises an error in case response status is not a success\n\t_checkStatus(response) {\n\t\tif (response.status >= 200 && response.status < 300) {\n\t\t\treturn response\n\t\t} else {\n\t\t\tvar error = new Error(response.statusText)\n\t\t\terror.response = response\n\t\t\tthrow error\n\t\t}\n\t}\n\n\t// performs api calls sending the required authentication headers\n\t// this is actually a wrapper around the 'fetch' function from\n\t// isomorphic fetch\n\tfetch(url, options){\n\t\tconst headers = {\n\t\t\t'Accept': 'application/json',\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\n\t\tif (this.loggedIn()){\n\t\t\theaders['Authorization'] = 'Bearer ' + this.getToken()\n\t\t}\n\n\t\treturn fetch(url, {\n\t\theaders,\n\t\t...options\n\t\t})\n\t\t.then(this._checkStatus)\n\t\t.then(response => response.json())\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}