{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\n\n/*\n * This is a helper utility that allows\n * authentication for pages\n * This is reusable across pages\n * The JWT token is stored as cookies\n */\n//redundant but this allows me to explicitly know fetch is from this package\nimport _fetch from 'isomorphic-unfetch'; //This class can be used as a service handler for login pages\n//or any form of authentication\n\nvar AuthService =\n/*#__PURE__*/\nfunction () {\n  //if domain is passed, then use that else fallback to localhost:5000\n  function AuthService(domain) {\n    _classCallCheck(this, AuthService);\n\n    this.domain = domain || 'http://localhost:1996';\n    this.fetch = this.fetch.bind(this);\n    this.login = this.login.bind(this);\n    this.getProfile = this.getProfile.bind(this);\n  } //signup a user\n\n\n  _createClass(AuthService, [{\n    key: \"signUp\",\n    value: function signUp(email, name, password) {\n      var _this = this;\n\n      return this.fetch(\"\".concat(this.domain, \"/user/add\"), {\n        method: 'POST',\n        body: _JSON$stringify({\n          email: email,\n          name: name,\n          password: password\n        })\n      }).then(function (res) {\n        _this.setToken(res.token); //arms the token\n\n\n        return _this.fetch(\"\".concat(_this.domain, \"/user/profile\"), {\n          method: 'GET'\n        });\n      }).then(function (res) {\n        _this.setProfile(res);\n\n        return _Promise.resolve(res);\n      });\n    } // Get a token\n\n  }, {\n    key: \"login\",\n    value: function login(email, password) {\n      var _this2 = this;\n\n      return this.fetch(\"\".concat(this.domain, \"/user/login\"), {\n        method: 'POST',\n        body: _JSON$stringify({\n          email: email,\n          password: password\n        })\n      }).then(function (res) {\n        _this2.setToken(res.token); //arms the token\n\n\n        return _this2.fetch(\"\".concat(_this2.domain, \"/user/profile\"), {\n          method: 'GET'\n        });\n      }).then(function (res) {\n        _this2.setProfile(res);\n\n        return _Promise.resolve(res);\n      });\n    } // Checks if there is a saved token and it's still valid\n\n  }, {\n    key: \"loggedIn\",\n    value: function loggedIn() {\n      //TODO : check validity of token ?\n      var token = this.getToken(); //return !!token && !isTokenExpired(token) // handwaiving here\n\n      return !!token;\n    }\n  }, {\n    key: \"setProfile\",\n    value: function setProfile(profile) {\n      // Saves profile data to localStorage\n      localStorage.setItem('profile', _JSON$stringify(profile));\n    }\n  }, {\n    key: \"getProfile\",\n    value: function getProfile() {\n      // Retrieves the profile data from localStorage\n      var profile = localStorage.getItem('profile');\n      return profile ? JSON.parse(localStorage.profile) : {};\n    } // Saves user token to localStorage\n\n  }, {\n    key: \"setToken\",\n    value: function setToken(idToken) {\n      localStorage.setItem('token', idToken);\n    } // Retrieves the user token from localStorage\n\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      return localStorage.getItem('token');\n    } // Clear user token and profile data from localStorage\n    // and logout user (from all device /all)\n\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      //only proceed if the user IS logged in\n      return this.fetch(\"\".concat(this.domain, \"/user/logout/all\"), {\n        method: 'POST'\n      }).then(function (res) {\n        //response is 204\n        console.log(\"Removing Storage\");\n        localStorage.removeItem('token');\n        localStorage.removeItem('profile');\n        return _Promise.resolve(res);\n      });\n    } // raises an error in case response status is not a success\n\n  }, {\n    key: \"_checkStatus\",\n    value: function _checkStatus(response) {\n      console.log(response.status);\n\n      if (response.status >= 200 && response.status < 300) {\n        return response;\n      } else {\n        var error = new Error(response.statusText);\n        error.response = response;\n        throw error;\n      }\n    } // performs api calls sending the required authentication headers\n    // this is actually a wrapper around the 'fetch' function from\n    // isomorphic fetch\n\n  }, {\n    key: \"fetch\",\n    value: function fetch(url, options) {\n      var headers = {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      };\n\n      if (this.loggedIn()) {\n        headers['Authorization'] = 'Bearer ' + this.getToken();\n      }\n\n      return _fetch(url, _objectSpread({\n        headers: headers\n      }, options)).then(this._checkStatus).then(function (response) {\n        return response.json();\n      });\n    }\n  }]);\n\n  return AuthService;\n}();\n\nexport { AuthService as default };","map":{"version":3,"sources":["/home/cjason/prodev/minextjs/utils/authser.js"],"names":["fetch","AuthService","domain","bind","login","getProfile","email","name","password","method","body","then","res","setToken","token","setProfile","resolve","getToken","profile","localStorage","setItem","getItem","JSON","parse","idToken","console","log","removeItem","response","status","error","Error","statusText","url","options","headers","loggedIn","_checkStatus","json"],"mappings":"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","sourcesContent":["/*\n * This is a helper utility that allows\n * authentication for pages\n * This is reusable across pages\n * The JWT token is stored as cookies\n */\n\n//redundant but this allows me to explicitly know fetch is from this package\nimport fetch from 'isomorphic-unfetch'\n\n//This class can be used as a service handler for login pages\n//or any form of authentication\nexport default class AuthService {\n\t//if domain is passed, then use that else fallback to localhost:5000\n\tconstructor(domain) {\n\t\tthis.domain = domain || 'http://localhost:1996'\n\t\tthis.fetch = this.fetch.bind(this)\n\t\tthis.login = this.login.bind(this)\n\t\tthis.getProfile = this.getProfile.bind(this)\n\t}\n\n\t//signup a user\n\tsignUp(email, name, password){\n\t\treturn this.fetch(`${this.domain}/user/add`, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({\n\t\t\temail,\n\t\t\tname,\n\t\t\tpassword\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setToken(res.token) //arms the token\n\t\t\treturn this.fetch(`${this.domain}/user/profile`, {\n\t\t\tmethod: 'GET'\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setProfile(res)\n\t\t\treturn Promise.resolve(res)\n\t\t})\n\t}\n\n\t// Get a token\n\tlogin(email, password) {\n\t\treturn this.fetch(`${this.domain}/user/login`, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({\n\t\t\temail,\n\t\t\tpassword\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setToken(res.token) //arms the token\n\t\t\treturn this.fetch(`${this.domain}/user/profile`, {\n\t\t\tmethod: 'GET'\n\t\t})\n\t\t}).then(res => {\n\t\t\tthis.setProfile(res)\n\t\t\treturn Promise.resolve(res)\n\t\t})\n\t}\n\n\t// Checks if there is a saved token and it's still valid\n\tloggedIn(){\n\t\t//TODO : check validity of token ?\n\t\tconst token = this.getToken()\n\t\t//return !!token && !isTokenExpired(token) // handwaiving here\n\t\treturn !!token\n\t}\n\n\tsetProfile(profile){\n\t\t// Saves profile data to localStorage\n\t\tlocalStorage.setItem('profile', JSON.stringify(profile))\n\t}\n\n\tgetProfile(){\n\t\t// Retrieves the profile data from localStorage\n\t\tconst profile = localStorage.getItem('profile')\n\t\treturn profile ? JSON.parse(localStorage.profile) : {}\n\t}\n\n\t// Saves user token to localStorage\n\tsetToken(idToken){\n\t\tlocalStorage.setItem('token', idToken)\n\t}\n\n\t// Retrieves the user token from localStorage\n\tgetToken(){\n\t\treturn localStorage.getItem('token')\n\t}\n\n\t// Clear user token and profile data from localStorage\n\t// and logout user (from all device /all)\n\tlogout(){\n\t\t//only proceed if the user IS logged in\n\t\treturn this.fetch(`${this.domain}/user/logout/all`, {\n\t\t\tmethod: 'POST'\n\t\t}).then(res => {\n\t\t\t//response is 204\n\t\t\tconsole.log(\"Removing Storage\")\n\t\t\tlocalStorage.removeItem('token');\n\t\t\tlocalStorage.removeItem('profile');\n\t\t\treturn Promise.resolve(res)\n\t\t})\n\t}\n\n\t// raises an error in case response status is not a success\n\t_checkStatus(response) {\n\t\tconsole.log(response.status)\n\t\tif (response.status >= 200 && response.status < 300) {\n\t\t\treturn response\n\t\t} else {\n\t\t\tvar error = new Error(response.statusText)\n\t\t\terror.response = response\n\t\t\tthrow error\n\t\t}\n\t}\n\n\t// performs api calls sending the required authentication headers\n\t// this is actually a wrapper around the 'fetch' function from\n\t// isomorphic fetch\n\tfetch(url, options){\n\t\tconst headers = {\n\t\t\t'Accept': 'application/json',\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\n\t\tif (this.loggedIn()){\n\t\t\theaders['Authorization'] = 'Bearer ' + this.getToken()\n\t\t}\n\n\t\treturn fetch(url, {\n\t\theaders,\n\t\t...options\n\t\t})\n\t\t.then(this._checkStatus)\n\t\t.then(response => response.json())\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}